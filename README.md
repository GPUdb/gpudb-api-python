# Kinetica Python API

This is the 7.1.x.y version of the client-side Python API for Kinetica.  The
first two components of the client version must match that of the Kinetica
server.  When the versions do not match, the API will print a warning.  Often,
there are breaking changes between versions, so it is critical that they match.
For example, Kinetica 6.2 and 7.0 have incompatible changes, so the 6.2.x.y
versions of the Python API would NOT be compatible with 7.0.a.b versions.

## Contents

* [Installation Instructions](#installation-instructions)
* [Troubleshooting Installation](#troubleshooting-installation)
* [GPUdb Table Monitor Client API](#gpudb-table-monitor-client-api)
* [GPUdbTableMonitorBase.Options](#gpudbtablemonitorbaseoptions)
* [GPUdbTableMonitorBase.Options Examples](#gpudbtablemonitorbaseoptions-examples)
* [GPUdbTableMonitorBase.Callbacks](#gpudbtablemonitorbasecallbacks)
* [Table Monitor Examples](#examples)


## Installation Instructions

To install this package, run 'python setup.py install' in the root directory of
the repo.  Note that due to the in-house compiled C-module dependency, this
package must be installed, and simply copying gpudb.py or having a link to it
will not work.

There is also an example file in the example directory.

The documentation can be found at http://www.kinetica.com/docs/7.1/index.html.  
The python specific documentation can be found at:

*   http://www.kinetica.com/docs/7.1/tutorials/python_guide.html
*   http://www.kinetica.com/docs/7.1/api/python/index.html


For changes to the client-side API, please refer to CHANGELOG.md.  For
changes to GPUdb functions, please refer to CHANGELOG-FUNCTIONS.md.


### Troubleshooting Installation

* If you get an error when running pip like

```
  "Traceback ... File "/bin/pip", line 5, in <module> from pkg_resources import load_entry_point"
```

please try upgrading pip with command:

```
    python -m pip install --upgrade --force pip
```

* If you get an error when running pip like
```
    "Exception: Traceback ... File "/usr/lib/python2.7/site-packages/pip/basecommand.py", line 215, in main status = self.run(options, args)"
```

please try downgrading your version of pip setuptools with command:

```
    pip install setuptools==33.1.1
```

## GPUdb Table Monitor Client API

A new API was introduced in version 7.0.17.0 to facilitate working with table
monitors, which watch for insert, update, and delete operations on a table.

The main class to use is `GPUdbTableMonitorBase`.  It can be instantiated
directly passing  custom callback functions which handle various monitor
events.  There are three types of monitor events:

| Monitor Event Type | Type of Payload Generated by the Event |
|:-------------------|:---------------------------------------|
| Insert             | A list of records                      |
| Update             | Count of updated rows                  |
| Delete             | Count of deleted rows                  |


Alternatively, the user can also derive from `GPUdbTableMonitorBase`; the
derived class must define the callback functions for the base class to use.
A default implementation, `GPUdbTableMonitor`, is provided which just logs the
table monitor events.  It is up to the user to choose whether to use an instance
of the base class or implement a derived class, based on the application's
design requirements.

Note that the current implementation, the `GPUdbTableMonitorBase` class is
designed to handle a single Kinetica table.


### GPUdbTableMonitorBase.Options

This class allows the user to configure the behavior of the
`GPUdbTableMonitorBase` class.  The following options are available:

| Property Name                           | Description | Default Value |
|:---                                     | :---        | :---          |
| ``operation_list``                      | A list which indicates which type(s) of table monitor(s) to create and subscribe to for the given table.  List members must be of type `TableEventType` (enum with values: `INSERT`, `UPDATE`, and `DELETE`).  The list can contain each enum value up to one time (no duplicates).  This option is mutually exclusive with the option `table_monitor_topic_id_list`; if using the latter, pass `None` for this option. | [``TableEventType.INSERT``] |
| ``terminate_on_table_altered``          | A boolean value indicating whether a table monitor is to be terminated when a change in the table schema is detected.  | *True* |
| ``check_gpudb_and_table_state_counter`` | A threshold for any period of inactivity in the table monitor; after the given number of inactive poll results, the API will check if the active Kinetica server is down.  If so, the API will failover to any available backup cluster and recreate the table monitor(s) there.  Keep in mind that the inactivity could also be due to the table not having had its data modified. | *500* |
| ``decode_failure_threshold``            | The number of seconds to restrict how long the program tries to decode a message after having failed the first time; the failure is possibly due to an alteration in the table schema. | *5 seconds* |
| ``ha_check_threshold``                  | The number of seconds the program checks to failover to any available backup cluster.  When the active database server cluster has not responded for a long time, and the API determines that it is time to failover to a backup cluster (if available), this option sets the timeout for the failover event. | *10 seconds* |
| ``zmq_polling_interval``                | This option controls the time interval to set the timeout for ZMQ socket polling. It is specified in milliseconds. | *1000 milliseconds* |
| ``table_monitor_topic_id_list``         | If the user wants to subscribe to table monitors that have already been created, use this option to pass in the `topic_ids`.  When used, the API will not attempt to create new table monitors, but subscribe to the existing ones instead.  Pass one `topic_id` per type of table monitor (i.e. insert, update, delete).  This option is mutually exclusive with the option `operation_list`; if using the latter, pass `None` for this option. | None |


#### GPUdbTableMonitorBase.Options Examples
```python
options = GPUdbTableMonitorBase.Options(
                                    _dict=dict(
                                    operation_list = None,
                                    NotificationEventType.TABLE_DROPPED],
                                    terminate_on_table_altered=True,
                                    check_gpudb_and_table_state_counter=500,
                                    decode_failure_threshold=5,
                                    ha_check_threshold=10,
                                    zmq_polling_interval=1000,
                                    table_monitor_topic_id_list=["oEdnBcnFw5xArIPbpxm9tA==","0qpcEpoMR+x7tBNDZ4lMhg==","PBvWoh0Dcmz8nr3ce8zW3w=="]
                                ))

options = GPUdbTableMonitorBase.Options(
                                    _dict=dict(
                                    operation_list = [TableEventType.INSERT],
                                    NotificationEventType.TABLE_DROPPED],
                                    terminate_on_table_altered=True,
                                    check_gpudb_and_table_state_counter=500,
                                    decode_failure_threshold=5,
                                    ha_check_threshold=10,
                                    zmq_polling_interval=1000,
                                    table_monitor_topic_id_list=None
                                ))


```

### GPUdbTableMonitorBase.Callbacks

This class contains the callback functions that the table monitor API uses to process events.  For each type of table monitor--insert, update, and delete--when an event occurs, the table monitor gets a notification.  For insertion, the monitor gets a list of binary-encoded records that have just been inserted into the table.  For update, the monitor gets a count of the number of rows updated.  And, for delete, the monitor gets a count of how many row were deleted.  The user can customize what to do with each type of event result.  The `GPUdbTableMonitorBase.Callbacks` class is used to pass the custom callback functions to the `GPUdbTableMonitorBase` class.

The callback functions are written by the user to plug into the table monitor API.  Each function must have a single argument that accepts the `payload` from the table monitor.  The table below describes what types of callback functions the API accepts and what value the single argument will contain for each callback function.  Note that not all callbacks need to be implemented by the user.  Choose based on your needs.  The API uses these callback functions to give the user the freedom to do whatever they need to do in their application; the API just becomes a medium for getting data out of the Kinetica table and into the user's application.

The `GPUdbTableMonitorBase.Callbacks` has the following members:

| Name                  | Purpose   | Payload Type |
|:----------------------|:----------|:-------------|
| ``cb_insert_raw``     | If provided, this callback function will be invoked when records are inserted to the target table.  The monitor API will pass the inserted records in raw (undecoded binary) form to this method, where they may be processed, as needed.  Note that the both ``cb_insert_raw`` and ``cb_insert_decoded`` can be provided.  | A list of raw binary data. |
| ``cb_insert_decoded`` | If provided, this callback function will be invoked when records are inserted to the target table.  However, the monitor API will first decode the binary-encode records, and pass the decoded records to the callback method.  Note that decoding the records takes time; so if the user has no need for the records themselves, but just wants some action to be triggered, the ``cb_insert_raw`` callback might be more appropriate to use.  Also note that the both ``cb_insert_decoded`` and ``cb_insert_raw`` can be provided.  | A list of decoded records. |
| ``cb_updated``        | If provided, this callback function will be invoked when records are updated in the target table.  The table monitor API will pass the number of records updated in the table to this method. | An integer indicating the count of records updated. |
| ``cb_deleted``        | If provided, this callback function will be invoked when records are deleted from the target table.  The table monitor API will pass the number of records deleted from the table to this method. | An integer indicating the count of records deleted. |
| ``cb_table_dropped``  | If provided, this callback function will be invoked when the table is dropped.  The API will pass the table name to the callback function. | A string indicating the name of the table dropped. |


### Examples

1.  [table_monitor_example_default_impl.py](./examples/table_monitor_example_default_impl.py)
    This example uses the class `GPUdbTableMonitor` to demonstrate how to use
    the default implementation provided by Kinetica for first-time users. The
    default behavior just logs the event payloads as they are received by the
    default callbacks.

2.  [table_monitor_example_basic_first.py](./examples/table_monitor_example_basic_first.py)
    This example demonstrates the use of `GPUdbTableMonitorBase` class in an
    example client class (`TableMonitorExampleClient`).  `TableMonitorExampleClient`
    defines callback functions as members, and it also has an instance of
    `GPUdbTableMonitorBase` as a member.  In this example, `TableMonitorExampleClient`
    runs the long-running thread by controlling `GPUdbTableMonitorBase`'s start
    and stop methods.

3.  [table_monitor_example_basic_second.py](./examples/table_monitor_example_basic_second.py)
    This example is a variant of the previous example.  In this example, the
    `TableMonitorExampleClient` class does _not_ contain an instance of
    `GPUdbTableMonitorBase` as a member.  Like the first example,
    `TableMonitorExampleClient` does define callback functions.  But, unlike the
    first example, an instance of `GPUdbTableMonitorBase` is created separately--
    outside the `TableMonitorExampleClient` class--in the main method. So, both
    `TableMonitorExampleClient` and `GPUdbTableMonitorBase` are constructed in
    the main method.

    This example shows the scenario where the client application cannot (or
    should not) use `GPUdbTableMonitorBase` in the application layer; instead
    `GPUdbTableMonitorsBase` class will exist outside the custom client code.
    The main method starts and stops the table monitor thread (implemented
    in `GPUdbTableMonitorBase`); therefore, this long-running process is outside
    of the context of the user's custom code.  Such a scenario would occur if
    the client application is designed to be unaware of the existence of
    Kinetica, but does need to trigger certain actions when the target table is
    altered.

4.  [table_monitor_example_queued_impl.py](./examples/table_monitor_example_queued_impl.py)
    This example defines a class called `QueuedGPUdbTableMonitor` which inherits
    from `GPUdbTableMonitorBase` and implements the callback functions.
    Additionally, this class has a Queue instance which is _shared with_ the
    client class `TableMonitorExampleClient`.  `TableMonitorExampleClient`
    inherits from Thread and runs in its own thread.  As the table monitor
    receives notifications it just pushes them into the shared Queue and then
    `TableMonitorExampleClient` consumes them from the shared Queue and
    displays them in the console.
